<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>
       Python Data Structures - C2 Sort &middot;  Hujiawei Bujidao
    </title>

    <meta name="generator" content="Hugo 0.29" />
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta property="og:title" content=" Python Data Structures - C2 Sort &middot;  Hujiawei Bujidao" />
  	<meta property="og:site_name" content="Hujiawei Bujidao" />
  	<meta property="og:url" content="https://hujiaweibujidao.github.io/blog/2014/05/07/python-data-structures---c2-sort/" />

    
  	<meta property="og:type" content="article" />
    <meta property="og:article:published_time" content="2014-05-07T00:00:00Z" />
    
    <meta property="og:article:tag" content="algorithm" />
    
    <meta property="og:article:tag" content="python" />
    
    

    <meta name="description" content="Happy Coding &amp; Enjoy Living" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://hujiaweibujidao.github.io/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://hujiaweibujidao.github.io/images/apple-touch-icon.png" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/hugo.css" />

    
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/highlight.css">
    
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/github-gist.css">
    
    <script src="https://hujiaweibujidao.github.io/js/highlight.js"></script>
    <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

    
    

    
      
          <link href="https://hujiaweibujidao.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Hujiawei Bujidao" />
      
      
    

    <link rel="canonical" href="https://hujiaweibujidao.github.io/blog/2014/05/07/python-data-structures---c2-sort/" />

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        

        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/">Home</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/android">Android</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/python">Python</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/swift">Swift</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/about">About</a>
            </li>
        

        <li class="nav-opened" role="presentation"><a href=""></a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/algorithm/">tags/algorithm</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/android/">tags/android</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/swift/">tags/swift</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/reactnative/">tags/reactnative</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/python/">tags/python</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/java/">tags/java</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/dev/">tags/dev</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/life/">tags/life</a></li>
    </ul>

    
    

    
        <a class="subscribe-button icon-feed" href="https://hujiaweibujidao.github.io/index.xml">Subscribe</a>
    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">




  <header class="main-header post-head" style="background-image: url(https://www.bing.com/ImageResolution.aspx?w=1366&amp;h=768)">
  

    <nav class="main-nav overlay clearfix">
    
        
    
    
        <a class="menu-button" href="#"><span class="burger">&#9776;</span><span class="word">Menu</span></a>
    
</nav>

    <div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">Python Data Structures - C2 Sort</h1>
            <h2 class="page-description">Hujiawei Bujidao</h2> <br/>
            
    <a class="bloglogo" href="https://github.com/hujiaweibujidao" target="_blank">
    <span class="icon-github" style="color:white;font-size:2em"></span>
    </a>
&nbsp;


    <a class="bloglogo" href="https://weibo.com/hujiaweiyinger" target="_blank">
        <span class="icon-twitter" style="color:white;font-size:2em"></span>
    </a>
&nbsp;




    <a class="bloglogo" href="https://www.linkedin.com/in/hujiaweibujidao" target="_blank">
        <span class="icon-linkedin" style="color:white;font-size:2em"></span>
    </a>
&nbsp;


        </div>
    </div>
</header>



<main class="content" role="main">
  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">Python Data Structures - C2 Sort</h1>
        

        <section class="post-meta">
        
          <span class="post-tag small"><a href="https://hujiaweibujidao.github.io/tags/algorithm/">#algorithm</a></span>
        
          <span class="post-tag small"><a href="https://hujiaweibujidao.github.io/tags/python/">#python</a></span>
        
        &nbsp;&nbsp;
        
          <time class="post-date" datetime="2014-05-07T00:00:00Z">
            2014/5/7
          </time>
        
        </section>
        <br/>
    </header>

    <section class="post-content">
      <p>Python数据结构篇(2) 排序 </p>

<p>参考内容：<br />
1.<a href="http://interactivepython.org/courselib/static/pythonds/index.html">Problem Solving with Python</a><br />
Chapter5: Search and Sorting <a href="http://interactivepython.org/courselib/static/pythonds/SortSearch/sorting.html">online_link</a><br />
2.<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms">算法导论</a></p>

<h4 id="排序总结">排序总结</h4>

<p>1.冒泡排序(bubble sort)：每个回合都从第一个元素开始和它后面的元素比较，如果比它后面的元素更大的话就交换，一直重复，直到这个元素到了它能到达的位置。每次遍历都将剩下的元素中最大的那个放到了序列的“最后”(除去了前面已经排好的那些元素)。注意检测是否已经完成了排序，如果已完成就可以退出了。时间复杂度$O(n^2)$</p>

<p><strong>Python支持对两个数字同时进行交换！<code>a,b = b,a</code>就可以交换a和b的值了。</strong></p>

<p><img src="https://hujiaweibujidao.github.io/images/algos/bubblesort.png" alt="image" /></p>

<pre><code class="language-python">def short_bubble_sort(a_list):
    exchanges = True
    pass_num = len(a_list) - 1
    while pass_num &gt; 0 and exchanges:
        exchanges = False
        for i in range(pass_num):
            if a_list[i] &gt; a_list[i + 1]:
                exchanges = True
                a_list[i],a_list[i+1] = a_list[i+1], a_list[i]
        pass_num = pass_num - 1


if __name__ == '__main__':
    a_list=[20, 40, 30, 90, 50, 80, 70, 60, 110, 100]
    short_bubble_sort(a_list)
    print(a_list)
</code></pre>

<p>2.选择排序(selection sort)：每个回合都选择出剩下的元素中最大的那个，选择的方法是首先默认第一元素是最大的，如果后面的元素比它大的话，那就更新剩下的最大的元素值，找到剩下元素中最大的之后将它放入到合适的位置就行了。和冒泡排序类似，只是找剩下的元素中最大的方式不同而已。时间复杂度$O(n^2)$</p>

<p><img src="https://hujiaweibujidao.github.io/images/algos/selectionsort.png" alt="image" /></p>

<pre><code>def selection_sort(a_list):
    for fill_slot in range(len(a_list) - 1, 0, -1):
        pos_of_max = 0
        for location in range(1, fill_slot + 1):
            if a_list[location] &gt; a_list[pos_of_max]:
                pos_of_max = location
        a_list[fill_slot],a_list[pos_of_max]=a_list[pos_of_max],a_list[fill_slot]


a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
selection_sort(a_list)
print(a_list)
</code></pre>

<p>3.插入排序(insertion sort)：每次假设前面的元素都是已经排好序了的，然后将当前位置的元素插入到原来的序列中，为了尽快地查找合适的插入位置，可以使用二分查找。时间复杂度$O(n^2)$，别误以为二分查找可以降低它的复杂度，因为插入排序还需要移动元素的操作！</p>

<p><img src="https://hujiaweibujidao.github.io/images/algos/insertionsort.png" alt="image" /></p>

<pre><code class="language-python">def insertion_sort(a_list):
    for index in range(1, len(a_list)):
        current_value = a_list[index]
        position = index
        while position &gt; 0 and a_list[position - 1] &gt; current_value:
            a_list[position] = a_list[position - 1]
            position = position - 1
        a_list[position] = current_value


def insertion_sort_binarysearch(a_list):
    for index in range(1, len(a_list)):
        current_value = a_list[index]
        position = index
        low=0
        high=index-1
        while low&lt;=high:
            mid=(low+high)/2
            if a_list[mid]&gt;current_value:
                high=mid-1
            else:
                low=mid+1
        while position &gt; low:
            a_list[position] = a_list[position - 1]
            position = position -1
        a_list[position] = current_value


a_list = [54, 26, 93, 15, 77, 31, 44, 55, 20]
insertion_sort(a_list)
print(a_list)
insertion_sort_binarysearch(a_list)
print(a_list)
</code></pre>

<p>4.合并排序(merge sort)：典型的是二路合并排序，将原始数据集分成两部分(不一定能够均分)，分别对它们进行排序，然后将排序后的子数据集进行合并，这是典型的分治法策略。时间复杂度$O(nlogn)$</p>

<p><img src="https://hujiaweibujidao.github.io/images/algos/mergesort.png" alt="image" /></p>

<p><img src="https://hujiaweibujidao.github.io/images/algos/mergesort2.png" alt="image" /></p>

<pre><code class="language-python">def merge_sort(a_list):
    print(&quot;Splitting &quot;, a_list)
    if len(a_list) &gt; 1:
        mid = len(a_list) // 2
        left_half = a_list[:mid]
        right_half = a_list[mid:]
        merge_sort(left_half)
        merge_sort(right_half)
        i=0;j=0;k=0;
        while i &lt; len(left_half) and j &lt; len(right_half):
            if left_half[i] &lt; right_half[j]:
                a_list[k] = left_half[i]
                i=i+1
            else:
                a_list[k] = right_half[j]
                j=j+1
            k=k+1
        while i &lt; len(left_half):
            a_list[k] = left_half[i]
            i=i+1
            k=k+1
        while j &lt; len(right_half):
            a_list[k] = right_half[j]
            j=j+1
            k=k+1
    print(&quot;Merging &quot;, a_list)


a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
merge_sort(a_list)
print(a_list)
</code></pre>

<p>算法导论2-4题利用合并排序可以在$O(nlogn)$的最坏情况下得到包含n个元素的数组的逆序对的数目。<br />
[下面使用的是C++来实现的，合并排序的代码格式类似算法导论]</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int calculateInversions(int arr[], int p, int r);
int mergeInversions(int arr[], int p, int q, int r);

int main(int argc, const char * argv[])
{
    int arr[] = {2,3,8,6,1};
    int count = calculateInversions(arr, 0, 4);
    cout &lt;&lt; &quot;count inversions : &quot; &lt;&lt; count &lt;&lt; endl;
    return 0;
}

int calculateInversions(int arr[], int p, int r) {
	int count=0;
	if(p &lt; r) {
	    int q = (p + r) / 2;
            count += calculateInversions(arr, p, q);
            count += calculateInversions(arr, q+1, r);
            count += mergeInversions(arr, p, q, r);  
	}
	return count;
}

int mergeInversions(int arr[], int p, int q, int r){
    int count=0;
    int n1=q-p+1, n2=r-q;
    int left[n1+1], right[n2+1];
    for (int i=0; i&lt;n1; i++) {
        left[i]=arr[p+i];
    }
    for (int j=0; j&lt;n2; j++) {
        right[j]=arr[q+1+j];
    }
    left[n1]=INT32_MAX;
    right[n2]=INT32_MAX;
    int i=0, j=0;
    for (int k=p; k&lt;=r; k++) {
        if (left[i]&lt;=right[j]) {
            arr[k]=left[i];
            i++;
        }else{
            arr[k]=right[j];
            count += n1-i;
            j++;
        }
    }
    return count;
}
</code></pre>

<p>5.快速排序(quick sort)：</p>

<p>想法一：如下图所示，(它同样可以按照下面提到的算法导论中将数组分成了4个不同的部分，但是这里其实有更好的解释方法) <strong>首先，它每次都是选择第一个元素都为主元，这个回合就是要确定主元的位置；然后，有两个指针，一个leftmark指向主元的后面一个位置，另一个rightmark指向要排序的数组最后一个元素；接着，两个指针分别向中间移动，leftmark遇到比主元大的元素停止，rightmark遇到比主元小的元素停止，如果此时leftmark&lt;rightmark，也就是说中间还有未处理(未确定与主元大小关系)的元素，那么就交换leftmark和rightmark位置上的元素，然后重复刚才的移动操作，直到rightmark&lt;leftmark；最后，停止移动时候rightmark就是主元要放置的位置，因为它停在一个比主元小的元素的位置上，之后交换主元和rightmark指向的元素即可。完了之后，递归地对主元左右两边的数组进行排序即可。</strong></p>

<p><img src="https://hujiaweibujidao.github.io/images/algos/quicksort.png" alt="image" /></p>

<pre><code class="language-python">def quick_sort(a_list):
    quick_sort_helper(a_list, 0, len(a_list) - 1)

def quick_sort_helper(a_list, first, last):
    if first &lt; last:
        split_point = partition(a_list, first, last)
        quick_sort_helper(a_list, first, split_point - 1)
        quick_sort_helper(a_list, split_point + 1, last)

def partition(a_list, first, last):
    pivot_value = a_list[first]
    left_mark = first + 1
    right_mark = last
    done = False
    while not done:
        while left_mark &lt;= right_mark and a_list[left_mark] &lt;= pivot_value:
            left_mark = left_mark + 1
        while a_list[right_mark] &gt;= pivot_value and right_mark &gt;= left_mark:
            right_mark = right_mark - 1
        if right_mark &lt; left_mark:
            done = True
        else:
            temp = a_list[left_mark]
            a_list[left_mark] = a_list[right_mark]
            a_list[right_mark] = temp
    temp = a_list[first]
    a_list[first] = a_list[right_mark]
    a_list[right_mark] = temp
    return right_mark

a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
quick_sort(a_list)
print(a_list)
</code></pre>

<p>想法二：(摘自算法导论)如下图所示，它选择最后的那个元素作为主元，它的思路是将数组划分成4部分：</p>

<p>第一部分：$p \le k \le i, A[k] \le pivot$<br />
第二部分：$i+1 \le k \le j-1, A[k] \gt pivot$<br />
第三部分：$j \le k \le r-1, A[k]$可以取任何值(因为它们还没有进行处理)<br />
第四部分：$p \le k \le i, A[k] = pivot$</p>

<p><strong>首先，让i指向要排序的数组的第一个元素的前面，p和j都指向第一个元素；然后，一直移动j直到主元前一个位置，一旦发现一个小于主元的元素就让i指向它的下一个位置，然后交换i和j对应位置上的元素。这样一定是可行的，因为i一直都是指向已发现的小于主元的元素中的最后一个，从i+1开始就大于主元了(或者还未确定/未处理)，而j一直都是指向大于主元的元素中最后一个的后面一个位置，所以i+1和j位置上的元素交换就可以使得j发现的这个小于主元的元素移动到第一部分，而i+1位置上大于主元的元素移动到j的位置上，即第二部分的最后一个位置上。</strong></p>

<p><img src="https://hujiaweibujidao.github.io/images/algos/quicksort_cn.png" alt="image" /></p>

<p>根据算法导论中的伪代码的C++版本实现</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// partition, locate the pivot value in properate position
int partition(int a[], int low, int high){
    int key = a[high];//pivot
    int i=low-1, temp;
    for (int j=low; j&lt;high; j++) {
        if (a[j]&lt;key) {
            i++;
            temp = a[j];
            a[j]=a[i];
            a[i]=temp;
        }
    }
    temp = a[high];
    a[high] = a[i+1];
    a[i+1] = temp;//i+1 is the split point
    return i+1;
}

// quick sort
void quicksort(int a[], int low, int high) {
    if (low &lt; high) {
        int p = partition(a,low,high);
        quicksort(a, low, p-1);
        quicksort(a, p+1, high);
    }
}

// print array
void print(int a[],int len){
    for (int i=0; i&lt;len; i++) {
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

int main(int argc, const char * argv[])
{
    int a[]={3,5,2,7,9,10,33,28,19,6,8};
    quicksort(a, 0, 10);
    print(a,11);
}
</code></pre>

<p>由于快排每次都能够确定一个元素在数组中最终的位置，所以可以用快排来解决很多变种问题，例如在线性时间内求中位数或者其他顺序统计量的问题(例如第k大或者第k小的元素)，该部分内容可以参考<a href="http://www.cnblogs.com/Anker/archive/2013/01/25/2877311.html">来自博客园</a></p>

<p>关于快排的性能分析可以参考<a href="http://www.cnblogs.com/Anker/archive/2013/01/24/2875234.html">来自博客园</a>，一般来说划分之后两边越均衡的话快排的性能更好。为了避免最坏的情况出现(原始的数组是已经是有序的)可以使用随机化版本的快排。</p>

<p>另外，为了减少快排调用的栈深度可以使用模拟尾递归技术，通过对快排的修改可以保证最坏情况下栈深度为O(nlgn)，该内容可以参见算法导论习题7-4。</p>

<p>6.希尔排序：类似合并排序和插入排序的结合体，二路合并排序将原来的数组分成左右两部分，希尔排序则将数组按照一定的间隔分成几部分，每部分采用插入排序来排序，有意思的是这样做了之后，元素很多情况下就差不多在它应该呆的位置，所以效率不一定比插入排序差。时间复杂度为$[O(n),O(n^2)]$。</p>

<p><img src="https://hujiaweibujidao.github.io/images/algos/shellsort.png" alt="image" /></p>

<p><img src="https://hujiaweibujidao.github.io/images/algos/shellsort2.png" alt="image" /></p>

<pre><code class="language-python">def shell_sort(a_list):
    #how many sublists, also how many elements in a sublist
    sublist_count = len(a_list) // 2
    while sublist_count &gt; 0:
        for start_position in range(sublist_count):
            gap_insertion_sort(a_list, start_position, sublist_count)
        print(&quot;After increments of size&quot;, sublist_count, &quot;The list is&quot;, a_list)
        sublist_count = sublist_count // 2

def gap_insertion_sort(a_list, start, gap):
    #start+gap is the second element in this sublist
    for i in range(start + gap, len(a_list), gap):
        current_value = a_list[i]
        position = i
        while position &gt;= gap and a_list[position - gap] &gt; current_value:
            a_list[position] = a_list[position - gap] #move backward
            position = position - gap
            a_list[position] = current_value


a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20, 88]
shell_sort(a_list)
print(a_list)
</code></pre>

<p>7.堆排序请参见该系列文章中的<a href="https://hujiaweibujidao.github.io/blog/2014/05/08/python-data-structures---c3-data-structures/">DataStrctures章节中的二叉堆部分的内容</a>。</p>

<p>8.其他线性排序可以参见算法导论第8章或者看下<a href="http://www.cnblogs.com/Anker/archive/2013/01/25/2876397.html">这篇不错的文章</a></p>

<p>其实看个图就明白了，图摘自上面的博客，版权归原作者，谢谢！</p>

<p>计数排序：在数的范围很小时还是不错的，当数的范围很大的时候就不适用了，计数排序一般用于基数排序中。需要注意的是，计数完了之后进行插入时，为了保证排序的稳定性，需要从后往前插入。</p>

<p><img src="https://hujiaweibujidao.github.io/images/algos/sortcount.png" alt="image" /></p>

<p>下面是计数排序的python实现，摘自<a href="http://link.springer.com/book/10.1007%2F978-1-4302-3238-4">Python Algorithms: Mastering Basic Algorithms in the Python Language</a></p>

<pre><code>from collections import defaultdict

def counting_sort(A, key=lambda x: x):
    B, C = [], defaultdict(list)  # Output and &quot;counts&quot;
    for x in A:
        C[key(x)].append(x)  # &quot;Count&quot; key(x)
    for k in range(min(C), max(C) + 1):  # For every key in the range
        B.extend(C[k])  # Add values in sorted order
    return B

seq = [randrange(100) for i in range(10)]
seq = counting_sort(seq)
</code></pre>

<p>基数排序：因为每位上的数字范围一般都是有限的，所以常配合使用计数排序对每位进行排序。
<img src="https://hujiaweibujidao.github.io/images/algos/sortradix.png" alt="image" /></p>

<p>桶排序：适用于元素是均匀分布的，在每个桶内采用插入排序。</p>

<p><img src="https://hujiaweibujidao.github.io/images/algos/sortbucket.png" alt="image" /></p>

<p>本节只是对各种排序进行一个介绍然后用python实现而已，更加详细地解释各种排序的内部思想的内容可以参见后面的<a href="https://hujiaweibujidao.github.io/blog/2014/07/01/python-algorithms---c4-induction-and-recursion-and-reduction/">Python算法设计篇之Induction&amp;Recursion&amp;Reduction</a></p>
    </section>

    <footer class="post-footer">
      
        <figure class="author-image">
            <a class="img" href="https://hujiaweibujidao.github.io/" style="background-image: url(https://hujiaweibujidao.github.io/images/logo.gif)"><span class="hidden">hujiawei's Picture</span></a>
        </figure>
      

      





<section class="author" style="width:100%;">
  <div class="author-meta" style="width:100%;text-align:center;">
    <span class="author-location icon-user"> Hujiawei is a mobile developer</span>
    <span class="author-location icon-location"> Guangdong, China</span>
    <span class="author-link icon-link"><a href="https://hujiaweibujidao.github.io/"> https://hujiaweibujidao.github.io/</a></span>
    <span class="author-profile" style="width:100%;line-height:1.5em;">本博客所有文章均为原创，请勿随意转载，如需转载请联系我 (<a href="mailto:hujiawei090807@gmail.com">hujiawei090807 AT gmail.com</a>)</span>

    <span class="author-profile" style="width:100%;line-height:2em;font-weight:bold;color:#df5000;margin-top:10px;">我在小专栏有个移动开发技术专栏，不定期分享移动开发的核心技术，总结移动开发的实战经验<br/>所有文章皆为原创，内容制作精良，保证干货满满，欢迎订阅 (<a style="color:#df5000;" href="https://xiaozhuanlan.com/u/javayhu">https://xiaozhuanlan.com/u/javayhu</a>) <br/>
    >>> 我最近在Android面试指南小专栏里面写了一篇稿子 <a style="color:#df5000;" href="https://xiaozhuanlan.com/topic/1932587460"> [Android面试——算法面试心得] </a>，欢迎阅读！&lt;&lt;&lt;  </span>

    <span class="author-profile" style="width:100%;line-height:1.5em;">下面的二维码是我个人维护的微信公众号“潇涧技术专栏”，会不定期分享移动开发的核心技术，欢迎关注！<br/>
    	<img src="https://hujiaweibujidao.github.io/images/qrcode_weixin.jpg" />
    </span>
  </div>
</section>


      
        <aside class="read-next">
  
      <span class="readmore-prev readmore-meta">PREV: <a href="https://hujiaweibujidao.github.io/blog/2014/05/06/python-data-structures---c1-search/"><h4>Python Data Structures - C1 Search</h4></a></span>
      
  

  
      <span class="readmore-next readmore-meta">NEXT: <a href="https://hujiaweibujidao.github.io/blog/2014/05/08/python-data-structures---c3-data-structures/"><h4>Python Data Structures - C3 Data Structures</h4></a></span>
      
  
</aside>
<br/>

      
      
      

	
	<div id="lv-container" data-id="city" data-uid="MTAyMC8zMTA1MS83NTk5">
		<script type="text/javascript">
	   (function(d, s) {
	       var j, e = d.getElementsByTagName(s)[0];

	       if (typeof LivereTower === 'function') { return; }

	       j = d.createElement(s);
	       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
	       j.async = true;

	       e.parentNode.insertBefore(j, e);
	   })(document, 'script');
		</script>
	<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
	</div>
	

	

		

		
		
		
		
		
		

		
		
	


    </footer>
</article>

</main>

    <footer class="site-footer clearfix">
        <a id="gotop" class="icon-arrow-up" href="#" title="back to top"></a>

        <section class="copyright"><a href="">Hujiawei Bujidao. </a> All rights reserved &copy; 2013 - 2018</section>
        
        <section class="poweredby">Proudly generated by <a href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme &nbsp;
            
            <script type="text/javascript">
                var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
                document.write(unescape("%3Cspan id='cnzz_stat_icon_1000165127'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1000165127%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
            </script>
        </section>
        
    </footer>
  </div> 
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/index.js"></script>

    
    
    
    

    
</body>
</html>

