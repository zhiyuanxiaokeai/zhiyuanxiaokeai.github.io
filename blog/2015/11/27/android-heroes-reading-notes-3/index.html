<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>
       Android Heroes Reading Notes 3 &middot;  Hujiawei Bujidao
    </title>

    <meta name="generator" content="Hugo 0.29" />
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta property="og:title" content=" Android Heroes Reading Notes 3 &middot;  Hujiawei Bujidao" />
  	<meta property="og:site_name" content="Hujiawei Bujidao" />
  	<meta property="og:url" content="https://hujiaweibujidao.github.io/blog/2015/11/27/android-heroes-reading-notes-3/" />

    
  	<meta property="og:type" content="article" />
    <meta property="og:article:published_time" content="2015-11-27T00:00:00Z" />
    
    <meta property="og:article:tag" content="android" />
    
    

    <meta name="description" content="Happy Coding &amp; Enjoy Living" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://hujiaweibujidao.github.io/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://hujiaweibujidao.github.io/images/apple-touch-icon.png" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/hugo.css" />

    
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/highlight.css">
    
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/github-gist.css">
    
    <script src="https://hujiaweibujidao.github.io/js/highlight.js"></script>
    <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

    
    

    
      
          <link href="https://hujiaweibujidao.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Hujiawei Bujidao" />
      
      
    

    <link rel="canonical" href="https://hujiaweibujidao.github.io/blog/2015/11/27/android-heroes-reading-notes-3/" />

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        

        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/">Home</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/android">Android</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/python">Python</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/swift">Swift</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/about">About</a>
            </li>
        

        <li class="nav-opened" role="presentation"><a href=""></a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/algorithm/">tags/algorithm</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/android/">tags/android</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/swift/">tags/swift</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/reactnative/">tags/reactnative</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/python/">tags/python</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/java/">tags/java</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/dev/">tags/dev</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/life/">tags/life</a></li>
    </ul>

    
    

    
        <a class="subscribe-button icon-feed" href="https://hujiaweibujidao.github.io/index.xml">Subscribe</a>
    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">




  <header class="main-header post-head" style="background-image: url(https://www.bing.com/ImageResolution.aspx?w=1366&amp;h=768)">
  

    <nav class="main-nav overlay clearfix">
    
        
    
    
        <a class="menu-button" href="#"><span class="burger">&#9776;</span><span class="word">Menu</span></a>
    
</nav>

    <div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">Android Heroes Reading Notes 3</h1>
            <h2 class="page-description">Hujiawei Bujidao</h2> <br/>
            
    <a class="bloglogo" href="https://github.com/hujiaweibujidao" target="_blank">
    <span class="icon-github" style="color:white;font-size:2em"></span>
    </a>
&nbsp;


    <a class="bloglogo" href="https://weibo.com/hujiaweiyinger" target="_blank">
        <span class="icon-twitter" style="color:white;font-size:2em"></span>
    </a>
&nbsp;




    <a class="bloglogo" href="https://www.linkedin.com/in/hujiaweibujidao" target="_blank">
        <span class="icon-linkedin" style="color:white;font-size:2em"></span>
    </a>
&nbsp;


        </div>
    </div>
</header>



<main class="content" role="main">
  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">Android Heroes Reading Notes 3</h1>
        

        <section class="post-meta">
        
          <span class="post-tag small"><a href="https://hujiaweibujidao.github.io/tags/android/">#android</a></span>
        
        &nbsp;&nbsp;
        
          <time class="post-date" datetime="2015-11-27T00:00:00Z">
            2015/11/27
          </time>
        
        </section>
        <br/>
    </header>

    <section class="post-content">
      <p>《Android群英传》读书笔记 (3) 第六章 Android绘图机制与处理技巧 + 第七章 Android动画机制与使用技巧 </p>

<h3 id="第六章-android绘图机制与处理技巧"><strong>第六章 Android绘图机制与处理技巧</strong></h3>

<p>1.屏幕尺寸信息<br />
屏幕大小：屏幕对角线长度，单位“寸”；<br />
分辨率：手机屏幕像素点个数，例如720x1280分辨率；<br />
PPI(Pixels Per Inch)：即DPI(Dots Per Inch)，它是对角线的像素点数除以屏幕大小得到的；<br />
系统屏幕密度：android系统定义了几个标准的DPI值作为手机的固定DPI。<br />
<strong>注：下图中有两处笔误，hdpi应该是480x800，xxhdpi应该是1080x1920</strong><br />
<img src="https://hujiaweibujidao.github.io/images/androidheros_dpi.png" alt="img" /></p>

<p>独立像素密度(DP)：android系统使用mdpi屏幕作为标准，在这个屏幕上1dp=1px，其他屏幕可以通过比例进行换算。在hdpi中，1dp=1.5px。在xhdpi中，1dp=2px。在xxhdpi中，1dp=3px。<br />
单位转换：常用的单位转换的辅助类DisplayUtil</p>

<pre><code>/**
 * 常用单位转换的辅助类
 */
public class DisplayUtil {

    /**
     * dp转px
     */
    public static int dp2px(Context context, float dpVal) {
        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
                dpVal, context.getResources().getDisplayMetrics());
    }

    /**
     * sp转px
     */
    public static int sp2px(Context context, float spVal) {
        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,
                spVal, context.getResources().getDisplayMetrics());
    }

    /**
     * px转dp
     */
    public static float px2dp(Context context, float pxVal) {
        final float scale = context.getResources().getDisplayMetrics().density;
        return (pxVal / scale);
    }

    /**
     * px转sp
     */
    public static float px2sp(Context context, float pxVal) {
        return (pxVal / context.getResources().getDisplayMetrics().scaledDensity);
    }
}
</code></pre>

<p>2.2D绘图基础<br />
(1)Canvas对象<br />
<code>drawPoint</code>，<code>drawLine</code>，<code>drawRect</code>，<code>drawRoundRect</code>，<code>drawCircle</code>，<code>drawArc</code>，<code>drawOval</code>，<code>drawText</code>，<code>drawPosText</code>(在指定位置绘制文本)，<code>drawPath</code>(绘制路径)</p>

<p>(2)Paint对象<br />
<code>setAntiAlias</code>：设置画笔的锯齿效果<br />
<code>setColor</code>：设置画笔的颜色<br />
<code>setARGB</code>：设置画笔的A、R、G、B值<br />
<code>setAlpha</code>：设置画笔的透明度值<br />
<code>setTextSize</code>：设置字体大小<br />
<code>setStyle</code>：设置画笔的效果（空心STROKE或者实心FILL）<br />
<code>setStrokeWidth</code>：设置空心边框的宽度</p>

<p>3.Android XML绘图<br />
(1)Bitmap<br />
在XML中定义Bitmap的语法</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;bitmap
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:src=&quot;@[package:]drawable/drawable_resource&quot;
    android:antialias=[&quot;true&quot; | &quot;false&quot;]
    android:dither=[&quot;true&quot; | &quot;false&quot;]
    android:filter=[&quot;true&quot; | &quot;false&quot;]
    android:gravity=[&quot;top&quot; | &quot;bottom&quot; | &quot;left&quot; | &quot;right&quot; | &quot;center_vertical&quot; |
                      &quot;fill_vertical&quot; | &quot;center_horizontal&quot; | &quot;fill_horizontal&quot; |
                      &quot;center&quot; | &quot;fill&quot; | &quot;clip_vertical&quot; | &quot;clip_horizontal&quot;]
    android:tileMode=[&quot;disabled&quot; | &quot;clamp&quot; | &quot;repeat&quot; | &quot;mirror&quot;] /&gt;
</code></pre>

<p>(2)Shape<br />
在XML中定义Shape的语法</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape    
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    
    android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;] &gt;    
    &lt;corners        //当shape为rectangle时使用
        android:radius=&quot;integer&quot;        //半径值会被后面的单个半径属性覆盖，默认为1dp
        android:topLeftRadius=&quot;integer&quot;        
        android:topRightRadius=&quot;integer&quot;        
        android:bottomLeftRadius=&quot;integer&quot;        
        android:bottomRightRadius=&quot;integer&quot; /&gt;    
    &lt;gradient       //渐变
        android:angle=&quot;integer&quot;        
        android:centerX=&quot;integer&quot;        
        android:centerY=&quot;integer&quot;        
        android:centerColor=&quot;integer&quot;        
        android:endColor=&quot;color&quot;        
        android:gradientRadius=&quot;integer&quot;        
        android:startColor=&quot;color&quot;        
        android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;]        
        android:useLevel=[&quot;true&quot; | &quot;false&quot;] /&gt;    
    &lt;padding        //内边距
        android:left=&quot;integer&quot;        
        android:top=&quot;integer&quot;        
        android:right=&quot;integer&quot;        
        android:bottom=&quot;integer&quot; /&gt;    
    &lt;size           //指定大小，一般用在imageview配合scaleType属性使用
        android:width=&quot;integer&quot;        
        android:height=&quot;integer&quot; /&gt;    
    &lt;solid          //填充颜色
        android:color=&quot;color&quot; /&gt;    
   	&lt;stroke         //边框
      	android:width=&quot;integer&quot;        
        android:color=&quot;color&quot;        
        android:dashWidth=&quot;integer&quot;        
        android:dashGap=&quot;integer&quot; /&gt;
&lt;/shape&gt;
</code></pre>

<p>(3)Layer<br />
在XML中定义Layer的语法，layer类似PS中图层的概念，语法如下</p>

<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:drawable=&quot;@[package:]drawable/drawable_resource&quot; /&gt;
    &lt;item android:drawable=&quot;@[package:]drawable/drawable_resource&quot; /&gt;
    ......
&lt;/layer-list&gt;
</code></pre>

<p>(4)Selector<br />
selector的用法很多，一般是定义控件在不同状态下的显示形态，可以是图片drawable，也可以是形状shape，还可以只是颜色color！</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;!-- 默认时的背景图片--&gt;
    &lt;item android:drawable=&quot;@drawable/pic1&quot;/&gt;
    &lt;!-- 没有焦点时的背景图片 --&gt;
    &lt;item android:drawable=&quot;@drawable/pic1&quot; android:state_window_focused=&quot;false&quot;/&gt;
    &lt;!-- 非触摸模式下获得焦点并单击时的背景图片 --&gt;
    &lt;item android:drawable=&quot;@drawable/pic2&quot; android:state_focused=&quot;true&quot; android:state_pressed=&quot;true&quot;/&gt;
    &lt;!-- 触摸模式下单击时的背景图片--&gt;
    &lt;item android:drawable=&quot;@drawable/pic3&quot; android:state_focused=&quot;false&quot; android:state_pressed=&quot;true&quot;/&gt;
    &lt;!--选中时的图片背景--&gt;
    &lt;item android:drawable=&quot;@drawable/pic4&quot; android:state_selected=&quot;true&quot;/&gt;
    &lt;!--获得焦点时的图片背景--&gt;
    &lt;item android:drawable=&quot;@drawable/pic5&quot; android:state_focused=&quot;true&quot;/&gt;
&lt;/selector&gt;
</code></pre>

<p>selector与shape结合的例子</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;!-- 定义当button处于pressed状态时的状态--&gt;
    &lt;item android:state_pressed=&quot;true&quot;&gt;
        &lt;shape&gt;
            &lt;gradient android:startColor=&quot;#8600ff&quot;/&gt;
            &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#000000&quot;/&gt;
            &lt;corners android:radius=&quot;5dp&quot;/&gt;
            &lt;padding android:bottom=&quot;10dp&quot; android:left=&quot;10dp&quot;
                     android:right=&quot;10dp&quot; android:top=&quot;10dp&quot;/&gt;
        &lt;/shape&gt;
    &lt;/item&gt;
    &lt;!-- 定义当button获得焦点时的状态--&gt;
    &lt;item android:state_focused=&quot;true&quot;&gt;
        &lt;shape&gt;
            &lt;gradient android:startColor=&quot;#eac100&quot;/&gt;
            &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#333333&quot;/&gt;
            &lt;corners android:radius=&quot;8dp&quot;/&gt;
            &lt;padding android:bottom=&quot;10dp&quot; android:left=&quot;10dp&quot;
                     android:right=&quot;10dp&quot; android:top=&quot;10dp&quot;/&gt;
        &lt;/shape&gt;
    &lt;/item&gt;
&lt;/selector&gt;
</code></pre>

<p>selector可以用来指定不同状态下文本的颜色，例如按钮上的文本的颜色</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:color=&quot;#999&quot; android:state_selected=&quot;true&quot;/&gt;
    &lt;item android:color=&quot;#666&quot; android:state_focused=&quot;true&quot;/&gt;
    &lt;item android:color=&quot;#333&quot; android:state_pressed=&quot;true&quot;/&gt;
    &lt;item android:color=&quot;#000&quot;/&gt;
&lt;/selector&gt;
</code></pre>

<p>结合这篇博文<a href="http://blog.csdn.net/brokge/article/details/9713041">Android开发：shape和selector和layer-list</a>以及博主的实现的<a href="http://blog.csdn.net/brokge/article/details/41318117">圆角镂空按钮</a>例子(综合使用了Shape、Layer和Selector实现了圆角镂空按钮)一起看还是挺不错的。</p>

<p>4.Android绘图技巧<br />
(1)Canvas 画布<br />
四个主要方法：<br />
<code>save</code>：保存画布，将之前绘制的内容保存起来；<br />
<code>restore</code>：合并画布，将save方法之后绘制的内容与之前绘制的内容合并起来；<br />
<code>translate</code>：移动画布，其实是画布所在的坐标系的移动；<br />
<code>rotate</code>：旋转画布，其实是画布所在的坐标系的旋转。</p>

<p>后面两个方法主要是用来方便在某些特殊情况下的绘制，例如书中介绍的仪表盘的绘制</p>

<pre><code>@Override
protected void onDraw(Canvas canvas) {
    // 获取宽高参数
    mWidth = getMeasuredWidth();
    mHeight = getMeasuredHeight();
    // 画外圆
    Paint paintCircle = new Paint();
    paintCircle.setStyle(Paint.Style.STROKE);
    paintCircle.setAntiAlias(true);
    paintCircle.setStrokeWidth(5);
    canvas.drawCircle(mWidth / 2, mHeight / 2, mWidth / 2, paintCircle);
    // 画刻度
    Paint painDegree = new Paint();
    paintCircle.setStrokeWidth(3);
    for (int i = 0; i &lt; 24; i++) {
        // 区分整点与非整点
        if (i == 0 || i == 6 || i == 12 || i == 18) {
            painDegree.setStrokeWidth(5);
            painDegree.setTextSize(30);
            canvas.drawLine(mWidth / 2, mHeight / 2 - mWidth / 2,
                    mWidth / 2, mHeight / 2 - mWidth / 2 + 60,
                    painDegree);
            String degree = String.valueOf(i);
            canvas.drawText(degree,
                    mWidth / 2 - painDegree.measureText(degree) / 2,
                    mHeight / 2 - mWidth / 2 + 90,
                    painDegree);
        } else {
            painDegree.setStrokeWidth(3);
            painDegree.setTextSize(15);
            canvas.drawLine(mWidth / 2, mHeight / 2 - mWidth / 2,
                    mWidth / 2, mHeight / 2 - mWidth / 2 + 30,
                    painDegree);
            String degree = String.valueOf(i);
            canvas.drawText(degree,
                    mWidth / 2 - painDegree.measureText(degree) / 2,
                    mHeight / 2 - mWidth / 2 + 60,
                    painDegree);
        }
        // 通过旋转画布简化坐标运算
        canvas.rotate(15, mWidth / 2, mHeight / 2);
    }
    // 画圆心
    Paint paintPointer = new Paint();
    paintPointer.setStrokeWidth(30);
    canvas.drawPoint(mWidth / 2, mHeight / 2, paintPointer);
    // 画指针
    Paint paintHour = new Paint();
    paintHour.setStrokeWidth(20);
    Paint paintMinute = new Paint();
    paintMinute.setStrokeWidth(10);
    canvas.save();
    canvas.translate(mWidth / 2, mHeight / 2);
    canvas.drawLine(0, 0, 100, 100, paintHour);
    canvas.drawLine(0, 0, 100, 200, paintMinute);
    canvas.restore();
}
</code></pre>

<p>(2)Layer 图层<br />
在Android中图层是基于栈的结构来管理的，通过调用<code>saveLayer</code>、<code>saveLayerAlpha</code>方法来创建图层，使用<code>restore</code>、<code>restoreToCount</code>方法将一个图层入栈。入栈的时候，后面所有的操作都发生在这个图层上，而出栈的时候则会把图像绘制在上层Canvas上。</p>

<pre><code>@Override
protected void onDraw(Canvas canvas) {
    canvas.drawColor(Color.WHITE);
    mPaint.setColor(Color.BLUE);
    canvas.drawCircle(150, 150, 100, mPaint);

    canvas.saveLayerAlpha(0, 0, 400, 400, 127, LAYER_FLAGS);
    mPaint.setColor(Color.RED);
    canvas.drawCircle(200, 200, 100, mPaint);
    canvas.restore();
}
</code></pre>

<p>仪表盘和Layer图层效果如下：<br />
<img src="https://hujiaweibujidao.github.io/images/androidheros_canvas.png" alt="img" />
<img src="https://hujiaweibujidao.github.io/images/androidheros_layer.png" alt="img" /></p>

<p>5.Android图像处理 <strong>[TODO：该部分略过了，自己暂时用的比较少，等需要用的时候学习下再补充]</strong><br />
色彩特效处理、图形特效处理、画笔特效处理</p>

<p>6.SurfaceView<br />
<strong>SurfaceView与View的区别</strong><br />
(1)View主要适用于主动更新的情况下，而SurfaceView主要适用于被动更新，例如频繁地刷新；<br />
(2)View在主线程中对画面进行刷新，而SurfaceView通常会通过一个子线程来进行页面刷新；<br />
(3)View在绘图时没有使用双缓冲机制，而SurfaceView在底层实现机制中就已经实现了双缓冲机制。</p>

<p>SurfaceView的使用<br />
(1)创建SurfaceView，一般继承自SurfaceView，并实现接口SurfaceHolderCallback。<br />
SurfaceHolderCallback接口的三个回调方法</p>

<pre><code>@Override
public void surfaceCreated(SurfaceHolder holder) {
  //做一些初始化操作，例如开启子线程通过循环来实现不停地绘制
}

@Override
public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
}

@Override
public void surfaceDestroyed(SurfaceHolder holder) {
}
</code></pre>

<p>(2)初始化SurfaceView<br />
初始化SurfaceHolder对象，并设置Callback</p>

<pre><code>private void initView() {
    mHolder = getHolder();
    mHolder.addCallback(this);
    ......
}
</code></pre>

<p>(3)使用SurfaceView<br />
通过lockCanvas方法获取Canvas对象进行绘制，并通过unlockCanvasAndPost方法对画布内容进行提交<br />
<strong>需要注意的是每次调用lockCanvas拿到的Canvas都是同一个Canvas对象，所以之前的操作都会保留，如果需要擦除，可以在绘制之前调用<code>drawColor</code>方法来进行清屏。</strong></p>

<pre><code>private void draw() {
    try {
        mCanvas = mHolder.lockCanvas();
        //mCanvas draw something
    } catch (Exception e) {
    } finally {
        if (mCanvas != null)
            mHolder.unlockCanvasAndPost(mCanvas);
    }
}
</code></pre>

<p>书中使用SurfaceView实现了简易画板</p>

<pre><code>public class SimpleDraw extends SurfaceView implements SurfaceHolder.Callback, Runnable {

    private SurfaceHolder mHolder;
    private Canvas mCanvas;
    private boolean mIsDrawing;
    private Path mPath;
    private Paint mPaint;

    public SimpleDraw(Context context) {
        super(context);
        initView();
    }

    public SimpleDraw(Context context, AttributeSet attrs) {
        super(context, attrs);
        initView();
    }

    public SimpleDraw(Context context, AttributeSet attrs,
                      int defStyle) {
        super(context, attrs, defStyle);
        initView();
    }

    private void initView() {
        mHolder = getHolder();
        mHolder.addCallback(this);
        setFocusable(true);
        setFocusableInTouchMode(true);
        this.setKeepScreenOn(true);
        mPath = new Path();
        mPaint = new Paint();
        mPaint.setColor(Color.RED);
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setStrokeWidth(40);
    }

    @Override
    public void surfaceCreated(SurfaceHolder holder) {
        mIsDrawing = true;
        new Thread(this).start();
    }

    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
    }

    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {
        mIsDrawing = false;
    }

    @Override
    public void run() {
        long start = System.currentTimeMillis();
        while (mIsDrawing) {
            draw();
        }
        long end = System.currentTimeMillis();
        // 50 - 100ms，经验值
        if (end - start &lt; 100) {
            try {
                Thread.sleep(100 - (end - start));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void draw() {
        try {
            mCanvas = mHolder.lockCanvas();
            mCanvas.drawColor(Color.WHITE);
            mCanvas.drawPath(mPath, mPaint);
        } catch (Exception e) {
        } finally {
            if (mCanvas != null)
                mHolder.unlockCanvasAndPost(mCanvas);
        }
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int x = (int) event.getX();
        int y = (int) event.getY();
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                mPath.moveTo(x, y);
                break;
            case MotionEvent.ACTION_MOVE:
                mPath.lineTo(x, y);
                break;
            case MotionEvent.ACTION_UP:
                break;
        }
        return true;
    }
}
</code></pre>

<p><br/></p>

<h3 id="第七章-android动画机制与使用技巧"><strong>第七章 Android动画机制与使用技巧</strong></h3>

<p>1.View动画 （视图动画）<br />
视图动画(Animation)框架定义了透明度(AlphaAnimation)、旋转(RotateAnimation)、缩放(ScaleAnimation)和位移(TranslateAnimation)几种常见的动画，控制的是View的内容，所以视图动画的缺陷就在于当某个元素发生视图动画后，其响应事件的位置还依然停留在原来的地方！</p>

<p><strong>实现原理是每次绘制视图时View所在的ViewGroup中的drawChild方法获取该View的Animation的Transformation值，然后调用canvas.concat(transformationToApply.getMatrix())，通过矩阵运算完成动画帧。如果动画没有完成，就继续调用invalidate方法，启动下次绘制来驱动动画，从而完成整个动画的绘制。</strong></p>

<p>动画集合(AnimationSet)：将多个视图动画组合起来<br />
动画监听器(AnimationListener)：提供动画的监听回调方法</p>

<p>2.属性动画<br />
Android 3.0之后添加了属性动画(Animator)框架，其中核心类ObjectAnimator能够自动驱动，在不影响动画效果的情况下减少CPU资源消耗。</p>

<p><strong>ObjectAnimator</strong><br />
创建ObjectAnimator只需通过它的静态工厂方法直接返回一个ObjectAnimator对象，参数包括view对象，以及view的属性名字，这个属性必须要有get/set方法，因为ObjectAnimator内部会通过反射机制来修改属性值。常用的可以直接使用属性动画的属性包括：<br />
(1)<code>translationX</code>和<code>translationY</code>：控制view从它布局容器左上角坐标偏移的位置；<br />
(2)<code>rotation</code>、<code>rotationX</code>和<code>rotationY</code>：控制view围绕支点进行2D和3D旋转；<br />
(3)<code>scaleX</code>和<code>scaleY</code>：控制view围绕着它的支点进行2D缩放；<br />
(4)<code>pivotX</code>和<code>pivotY</code>：控制支点位置，围绕这个支点进行旋转和缩放处理。默认情况下，支点是view的中心点；<br />
(5)<code>x</code>和<code>y</code>：控制view在它的容器中的最终位置，它是最初的左上角坐标和translationX、translationY的累计和；<br />
(6)<code>alpha</code>：控制透明度，默认是1（不透明）。</p>

<p>ObjectAnimator的常见使用方式如下：</p>

<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 300);
animator.setDuration(1000);
animator.start();
</code></pre>

<p>属性动画集合AnimatorSet：控制多个动画的协同工作方式，常用方法<code>animatorSet.play().with().before().after()</code>、<code>playTogether</code>、<code>playSequentially</code>等方法来精确控制动画播放顺序。使用<code>PropertyValueHolder</code>也可以实现简单的动画集合效果。</p>

<p>动画监听器：监听动画事件可以使用<code>AnimatorListener</code>或者简易的适配器<code>AnimatorListenerAdapter</code></p>

<p><strong>如果一个属性没有get/set方法怎么办？</strong><br />
(1)自定义包装类，间接地给属性提供get/set方法，下面就是一个包装类的例子，为width属性提供了get/set方法</p>

<pre><code>public class WrapperView {

    private View mView;

    public WrapperView(View mView){
        this.mView = mView;
    }

    public int getWidth(){
        return mView.getLayoutParams().width;
    }

    public void setWidth(int width){
        mView.getLayoutParams().width = width;
        mView.requestLayout();
    }
}
</code></pre>

<p>(2)使用<code>ValueAnimator</code><br />
ObjectAnimator就是继承自ValueAnimator的，它是属性动画的核心，ValueAnimator不提供任何动画效果，它就是一个数值产生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程，控制的方式是使用<code>AnimatorUpdateListener</code>来监听数值的变换。</p>

<pre><code>ValueAnimator animator = ValueAnimator.ofFloat(0,100);
animator.setTarget(view);
animator.setDuration(1000);
animator.start();
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        Float value = (Float) animation.getAnimatedValue();
        //do the animation!
    }
});
</code></pre>

<p><strong>在XML中使用属性动画</strong><br />
下面是一个简单例子：</p>

<pre><code>&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;4000&quot;
    android:propertyName=&quot;rotation&quot;
    android:valueFrom=&quot;0&quot;
    android:valueTo=&quot;360&quot; /&gt;
</code></pre>

<p>在代码中使用方式如下： <strong>[注：测试该代码的时候，上面的xml定义应该放在res的animator目录下，放在anim目录下不行]</strong></p>

<pre><code>Animator animator = AnimatorInflater.loadAnimator(this, R.animator.animator_rotation);
animator.setTarget(view);
animator.start();
</code></pre>

<p><strong>View的animate方法</strong><br />
Android 3.0之后View新增了animate方法直接驱动属性动画，它其实是属性动画的一种简写方式</p>

<pre><code>imageView.animate().alpha(0).y(100).setDuration(1000)
        .setListener(new Animator.AnimatorListener() {
            @Override
            public void onAnimationStart(Animator animation) {
            }

            @Override
            public void onAnimationEnd(Animator animation) {
            }

            @Override
            public void onAnimationCancel(Animator animation) {
            }

            @Override
            public void onAnimationRepeat(Animator animation) {
            }
        });
</code></pre>

<p>3.布局动画<br />
布局动画是作用在ViewGroup上的，给ViewGroup添加view时添加动画过渡效果。<br />
(1)简易方式（但是没有什么效果）：在xml中添加如下属性 <code>android:animateLayoutChanges=&quot;true</code><br />
(2)通过<code>LayoutAnimationController</code>来自定义子view的过渡效果，下面是一个常见的使用例子：</p>

<pre><code>LinearLayout linearLayout = (LinearLayout) findViewById(R.id.ll);
ScaleAnimation scaleAnimation = new ScaleAnimation(0,1,0,1);
scaleAnimation.setDuration(2000);
LayoutAnimationController controller = new LayoutAnimationController(scaleAnimation, 0.5f);
controller.setOrder(LayoutAnimationController.ORDER_NORMAL);//NORMAL 顺序 RANDOM 随机 REVERSE 反序
linearLayout.setLayoutAnimation(controller);
</code></pre>

<p>4.自定义动画<br />
创建自定义动画就是要实现它的<code>applyTransformation</code>的逻辑，不过通常还需要覆盖父类的<code>initialize</code>方法来实现初始化工作。
下面是一个模拟电视机关闭的动画</p>

<pre><code>public class CustomTV extends Animation {

    private int mCenterWidth;
    private int mCenterHeight;

    @Override
    public void initialize(int width, int height, int parentWidth, int parentHeight) {
        super.initialize(width, height, parentWidth, parentHeight);
        setDuration(1000);// 设置默认时长
        setFillAfter(true);// 动画结束后保留状态
        setInterpolator(new AccelerateInterpolator());// 设置默认插值器
        mCenterWidth = width / 2;
        mCenterHeight = height / 2;
    }

    @Override
    protected void applyTransformation(float interpolatedTime, Transformation t) {
        final Matrix matrix = t.getMatrix();
        matrix.preScale(1, 1 - interpolatedTime, mCenterWidth, mCenterHeight);
    }
}
</code></pre>

<p>applyTransformation方法的第一个参数interpolatedTime是插值器的时间因子，取值在0到1之间；第二个参数Transformation是矩阵的封装类，一般使用它来获得当前的矩阵Matrix对象，然后对矩阵进行操作，就可以实现动画效果了。</p>

<p><strong>如何实现3D动画效果呢？</strong><br />
使用<code>android.graphics.Camera</code>中的Camera类，它封装了OpenGL的3D动画。可以把Camera想象成一个真实的摄像机，当物体固定在某处时，只要移动摄像机就能拍摄到具有立体感的图像，因此通过它可以实现各种3D效果。<br />
下面是一个3D动画效果的例子</p>

<pre><code>public class CustomAnim extends Animation {

    private int mCenterWidth;
    private int mCenterHeight;
    private Camera mCamera = new Camera();
    private float mRotateY = 0.0f;

    @Override
    public void initialize(int width, int height, int parentWidth, int parentHeight) {
        super.initialize(width, height, parentWidth, parentHeight);
        setDuration(2000);// 设置默认时长
        setFillAfter(true);// 动画结束后保留状态
        setInterpolator(new BounceInterpolator());// 设置默认插值器
        mCenterWidth = width / 2;
        mCenterHeight = height / 2;
    }

    // 暴露接口-设置旋转角度
    public void setRotateY(float rotateY) {
        mRotateY = rotateY;
    }

    @Override
    protected void applyTransformation( float interpolatedTime, Transformation t) {
        final Matrix matrix = t.getMatrix();
        mCamera.save();
        mCamera.rotateY(mRotateY * interpolatedTime);// 使用Camera设置旋转的角度
        mCamera.getMatrix(matrix);// 将旋转变换作用到matrix上
        mCamera.restore();
        // 通过pre方法设置矩阵作用前的偏移量来改变旋转中心
        matrix.preTranslate(mCenterWidth, mCenterHeight);
        matrix.postTranslate(-mCenterWidth, -mCenterHeight);
    }
}
</code></pre>

<p>5.Android 5.X SVG矢量动画机制 <strong>[TODO：该部分略过了，自己暂时用的比较少，等需要用的时候学习下再补充]</strong><br />
本章最后还有几个很常用的动画实例，感兴趣可以看下。</p>

<p>OK，本节结束，谢谢阅读。</p>
    </section>

    <footer class="post-footer">
      
        <figure class="author-image">
            <a class="img" href="https://hujiaweibujidao.github.io/" style="background-image: url(https://hujiaweibujidao.github.io/images/logo.gif)"><span class="hidden">hujiawei's Picture</span></a>
        </figure>
      

      





<section class="author" style="width:100%;">
  <div class="author-meta" style="width:100%;text-align:center;">
    <span class="author-location icon-user"> Hujiawei is a mobile developer</span>
    <span class="author-location icon-location"> Guangdong, China</span>
    <span class="author-link icon-link"><a href="https://hujiaweibujidao.github.io/"> https://hujiaweibujidao.github.io/</a></span>
    <span class="author-profile" style="width:100%;line-height:1.5em;">本博客所有文章均为原创，请勿随意转载，如需转载请联系我 (<a href="mailto:hujiawei090807@gmail.com">hujiawei090807 AT gmail.com</a>)</span>

    <span class="author-profile" style="width:100%;line-height:2em;font-weight:bold;color:#df5000;margin-top:10px;">我在小专栏有个移动开发技术专栏，不定期分享移动开发的核心技术，总结移动开发的实战经验<br/>所有文章皆为原创，内容制作精良，保证干货满满，欢迎订阅 (<a style="color:#df5000;" href="https://xiaozhuanlan.com/u/javayhu">https://xiaozhuanlan.com/u/javayhu</a>) <br/>
    >>> 我最近在Android面试指南小专栏里面写了一篇稿子 <a style="color:#df5000;" href="https://xiaozhuanlan.com/topic/1932587460"> [Android面试——算法面试心得] </a>，欢迎阅读！&lt;&lt;&lt;  </span>

    <span class="author-profile" style="width:100%;line-height:1.5em;">下面的二维码是我个人维护的微信公众号“潇涧技术专栏”，会不定期分享移动开发的核心技术，欢迎关注！<br/>
    	<img src="https://hujiaweibujidao.github.io/images/qrcode_weixin.jpg" />
    </span>
  </div>
</section>


      
        <aside class="read-next">
  
      <span class="readmore-prev readmore-meta">PREV: <a href="https://hujiaweibujidao.github.io/blog/2015/11/26/android-heroes-reading-notes-2/"><h4>Android Heroes Reading Notes 2</h4></a></span>
      
  

  
      <span class="readmore-next readmore-meta">NEXT: <a href="https://hujiaweibujidao.github.io/blog/2015/11/28/android-heroes-reading-notes-4/"><h4>Android Heroes Reading Notes 4</h4></a></span>
      
  
</aside>
<br/>

      
      
      

	
	<div id="lv-container" data-id="city" data-uid="MTAyMC8zMTA1MS83NTk5">
		<script type="text/javascript">
	   (function(d, s) {
	       var j, e = d.getElementsByTagName(s)[0];

	       if (typeof LivereTower === 'function') { return; }

	       j = d.createElement(s);
	       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
	       j.async = true;

	       e.parentNode.insertBefore(j, e);
	   })(document, 'script');
		</script>
	<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
	</div>
	

	

		

		
		
		
		
		
		

		
		
	


    </footer>
</article>

</main>

    <footer class="site-footer clearfix">
        <a id="gotop" class="icon-arrow-up" href="#" title="back to top"></a>

        <section class="copyright"><a href="">Hujiawei Bujidao. </a> All rights reserved &copy; 2013 - 2018</section>
        
        <section class="poweredby">Proudly generated by <a href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme &nbsp;
            
            <script type="text/javascript">
                var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
                document.write(unescape("%3Cspan id='cnzz_stat_icon_1000165127'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1000165127%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
            </script>
        </section>
        
    </footer>
  </div> 
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/index.js"></script>

    
    
    
    

    
</body>
</html>

